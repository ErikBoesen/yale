#!/usr/bin/env python3
import argparse
import os
import yaml
import stat
import sys
import requests
from termcolor import colored, cprint
import yaledining
import yalecourses
import yalebuildings
import yaledirectory
import yaleorgdirectory
from pick import pick

parser = argparse.ArgumentParser(description='Perform Yale-related tasks')
parser.add_argument('--debug', default=False, action='store_true', help='Output debug information')
subparsers = parser.add_subparsers(help='Subcommand help', dest='subcommand', required=True)
parser_dining = subparsers.add_parser('dining', help='Get information about the dining locations currently open, their menus, etc.')
parser_dining.add_argument('location', nargs='?', help='Specify a location to get information about')
parser_dining.add_argument('--menu', action='store_true', help='View a dining hall\'s full menu')
parser_courses = subparsers.add_parser('courses', help='Get information about courses and subjects offered at Yale')
parser_courses.add_argument('identifier', help='The course name or subject area to get information about')
parser_building = subparsers.add_parser('building', help='Learn about the buildings on campus')
parser_building.add_argument('building_id', help='The ID of the building to learn about')
parser_people = subparsers.add_parser('people', help='Look up people in the Yale directory')
parser_people.add_argument('person_name', help='Name of person to search for')
parser_organizations = subparsers.add_parser('organizations', help='Research organizations and institutions on campus')
parser_organizations.add_argument('organization_name', nargs='?', help='Name of organization to search for')
parser_organizations.add_argument('-t', dest='tags', nargs='*', help='Tags to narrow your search')
args = parser.parse_args()

CREDENTIALS_PATH = os.path.expanduser('~') + '/.yale_credentials.yml'
credentials = {
    'NetID': '',
    'Password': '',
    'yale_api_key': '',
}
if os.path.isfile(CREDENTIALS_PATH) and os.path.getsize(CREDENTIALS_PATH) is not 0:
    with open(CREDENTIALS_PATH, 'r') as f:
        credentials = yaml.load(f, Loader=yaml.SafeLoader)
else:
    credentials['NetID'] = input('NetID: ')
    from getpass import getpass
    credentials['Password'] = getpass('Password: ')
    credentials['yale_api_key'] = input('Yale API key (go to https://yale.dev.ca.com/admin/app/applications and add an application): ')
    with open(CREDENTIALS_PATH, 'w') as f:
        yaml.dump(credentials, f)
    os.chmod(CREDENTIALS_PATH, stat.S_IRUSR | stat.S_IWUSR)

# Warn if group or public can read config and the private details therein.
if os.stat(CREDENTIALS_PATH).st_mode & (stat.S_IRGRP | stat.S_IROTH):
    print('Warning: config file may be accessible by other users.', file=sys.stderr)

CONFIG_PATH = os.path.expanduser('~') + '/.yale.yml'
config = {
}
if os.path.isfile(CONFIG_PATH) and os.path.getsize(CONFIG_PATH) is not 0:
    with open(CONFIG_PATH, 'r') as f:
        config = yaml.load(f, Loader=yaml.SafeLoader)
else:
    config = {key: input(key + ': ') for key in config.keys()}
    config.update({
        'show_closed': False,
    })
    with open(CONFIG_PATH, 'w') as f:
        yaml.dump(config, f)

def debug(content):
    """
    Log debug output if enabled.
    :param content: content to log
    """
    if args.debug:
        print(content)

def error(content):
    """
    Log errors.
    :param content: content to log
    """
    print(colored(content, 'red'), file=sys.stderr)

def capacity_color(capacity):
    if capacity > 7: return 'red'
    if capacity > 5: return 'yellow'
    return 'green'

def capacity_bar(open, capacity):
    if not open or capacity is None:
        return ''
    return colored(('‚ñá' * capacity) + ('‚ñë' * (10 - capacity)), capacity_color(capacity))

def bullet(title, details: str = ''):
    if details:
        print(colored(title + ': ', 'blue') + details)

def bullet_list(title, details: list):
    # Make sure we don't log nothing
    if details:
        title += ': '
        print(colored(title, 'blue') + details.pop(0), end='')
        for detail in details:
            print(',\n' + ' ' * len(title) + detail, end='')
        print()

def log_organization(organization):
    bullet('Name', organization.name)
    bullet('Website', organization.website)
    bullet('Address', organization.address)
    bullet('Room', organization.room)
    bullet('Telephone', organization.telephone)

if args.subcommand == 'dining':
    api = yaledining.YaleDining()
    # Reshuffle into list of dicts for easy subscripting
    type_symbols = {
        'Residential': 'üè†',
        'Retail': 'üí∞',
    }
    if args.location is None:
        locations = api.locations()
        locations_open = [location for location in locations if location.open]
        if locations_open:
            for location in locations_open:
                debug(location)
                print(colored(type_symbols[location.type] + ' ' + location.name, 'green') + ' ' + capacity_bar(location.open, location.capacity))
        else:
            print(colored('No dining locations open currently.', 'blue'))
        if config['show_closed']:
            locations_closed = [location for location in locations if location.closed]
            if locations_closed:
                print(colored('Closed: ' + ', '.join([location.name for location in locations_closed]), 'grey'))
    else:
        location = api.location(args.location)
        if location is None:
            error('Unknown location name.')
        print(colored('/' * 3 + ' ' + location.name + ' ' + '/' * 3, 'blue'))
        print()
        bullet('Address', '{address} ({coordinates})'.format(address=location.address,
                                                             coordinates=location.geolocation))
        bullet('Phone', location.phone)
        bullet_list('Managers', [f'{manager.name} ({manager.email})' for manager in location.managers])
        for meal in location.meals:
            print()
            print(colored(meal.date.strftime('%m/%d') + ' / ' + meal.name, 'blue', attrs=['underline']))
            for item in meal.items:
                print('- ' + item.name)
elif args.subcommand == 'courses':
    api = yalecourses.YaleCourses(credentials['yale_api_key'])
    if yalecourses.is_subject(args.identifier):
        courses = api.courses(args.identifier)
        if not courses:
            print(args.identifier + ' is not a recognized subject.')
        else:
            for course in courses:
                bullet(course.code, course.name)
    else:
        course = api.course(args.identifier)
        if not course:
            print(args.identifier + ' is not a recognized course.')
        else:
            bullet(course.code, course.name)
            if course.meeting_patterns:
                bullet('Meeting schedule(s)', ', '.join(course.meeting_patterns))
            bullet('Professors', ', '.join(course.instructors))
            bullet('School', course.school_name)
            bullet('Registration available', ('YES' if course.active else 'NO'))
            bullet('Description')
            print(course.raw_description)
elif args.subcommand == 'building':
    api = yalebuildings.YaleBuildings(credentials['yale_api_key'])
    building = api.building(args.building_id)
    bullet(building.id, building.name)
    if building.category:
        bullet('Category', building.category)

    bullet_list('Address', [building.address_1, building.address_2 + ' ' + building.address_3])
    if building.latitude and building.longitude:
        bullet('Coordinates', f'({building.latitude}, {building.longitude})')
    if building.historical_name:
        bullet('Historical name', building.historical_name)
    if building.prose:
        bullet('Fun facts', building.fun_facts)
elif args.subcommand == 'people':
    pass
elif args.subcommand == 'organizations':
    api = yaleorgdirectory.YaleOrgDirectory(credentials['yale_api_key'])
    if args.organization_name:
        organization = api.organization(args.organization_name)
        log_organization(organization)
    else:
        organizations = api.organizations(tags=args.tags)
        name, index = pick([organization.name for organization in organizations])
        organization = api.organization(name)
        log_organization(organization)
