#!/usr/bin/env python3
import argparse
import os
import yaml
import stat
import sys
import requests
from termcolor import colored, cprint

parser = argparse.ArgumentParser(description='Perform Yale-related tasks')
subparsers = parser.add_subparsers(help='Subcommand help', dest='subcommand', required=True)
parser_dining = subparsers.add_parser('dining')
parser_dining.add_argument('location', nargs='?')
parser.add_argument('--debug', default=False, action='store_true', help='Output debug information')
args = parser.parse_args()

CREDENTIALS_PATH = os.path.expanduser('~') + '/.yale_credentials.yml'
credentials = {
    'NetID': '',
    'Password': '',
}
if os.path.isfile(CREDENTIALS_PATH) and os.path.getsize(CREDENTIALS_PATH) is not 0:
    with open(CREDENTIALS_PATH, 'r') as f:
        credentials = yaml.load(f, Loader=yaml.SafeLoader)
else:
    credentials['NetID'] = input('NetID: ')
    from getpass import getpass
    credentials['Password'] = getpass('Password: ')
    with open(CREDENTIALS_PATH, 'w') as f:
        yaml.dump(credentials, f)
    os.chmod(CREDENTIALS_PATH, stat.S_IRUSR | stat.S_IWUSR)

# Warn if group or public can read config and the private details therein.
if os.stat(CREDENTIALS_PATH).st_mode & (stat.S_IRGRP | stat.S_IROTH):
    print('Warning: config file may be accessible by other users.', file=sys.stderr)

CONFIG_PATH = os.path.expanduser('~') + '/.yale.yml'
config = {
}
if os.path.isfile(CONFIG_PATH) and os.path.getsize(CONFIG_PATH) is not 0:
    with open(CONFIG_PATH, 'r') as f:
        config = yaml.load(f, Loader=yaml.SafeLoader)
else:
    config = {key: input(key + ': ') for key in config.keys()}
    config.update({
        # Nothing here yet
    })
    with open(CONFIG_PATH, 'w') as f:
        yaml.dump(config, f)

def debug(content):
    """
    Log debug output if enabled.
    :param content: content to log
    """
    if args.debug:
        print(content)

def error(content):
    """
    Log errors.
    :param content: content to log
    """
    print(colored(content, 'red'), file=sys.stderr)

def capacity_color(capacity):
    if capacity > 7: return 'red'
    if capacity > 5: return 'yellow'
    return 'green'

def capacity_bar(is_open, capacity):
    if not is_open:
        return ''
    return colored(('â–‡' * capacity) + ('â–‘' * (10 - capacity)), capacity_color(capacity))

def get_managers(location):
    managers = []
    num_managers = 0
    while num_managers < 4:
        num_managers += 1
        manager = (location[f'MANAGER{num_managers}NAME'],
                   location[f'MANAGER{num_managers}EMAIL'])
        if manager == (None, None):
            break
        managers.append(manager)
    return ', '.join([f'{name} ({email})' for name, email in managers])

def dining_get(endpoint, version=3, make_list=True, params={}):
    custom_params = {
        'version': version,
    }
    custom_params.update(params)
    request = requests.get('http://www.yaledining.org/fasttrack/locations.cfm', params=custom_params)
    if request.ok:
        data = request.json()
        if make_list:
            data = [
                {response['COLUMNS'][index]: entry[index] for index in range(len(entry))}
                for entry in response['DATA']
            ]
        return data
    else:
        # TODO: actually say what's wrong
        raise Exception

if args.subcommand == 'dining':
    response = dining_get('locations.cfm')
    # Reshuffle into list of dicts for easy subscripting
    type_symbols = {
        'Residential': 'ðŸ ',
        'Retail': 'ðŸ’°',
    }
    if args.location is None:
        for location in locations:
            debug(location)
            is_open = not bool(location['ISCLOSED'])
            print(colored(type_symbols[location['TYPE']] + ' ' + location['DININGLOCATIONNAME'], 'green' if is_open else 'red'), end='')
            print(' ' + capacity_bar(is_open, location['CAPACITY']))
            if is_open:
                print(' - Address: {address} ({coordinates})'.format(address=location['ADDRESS'],
                                                                  coordinates=location['GEOLOCATION']))
                print(' - Phone: ' + location['PHONE'])
                print(' - Managers: ' + get_managers(location))
                print()
    else:
        location_id = None
        for location in locations:
            if args.location == location['DININGLOCATIONNAME']:
                location_id = location['ID_LOCATION']
        if location_id is None:
            error(f'Unknown location name.')
        response = dining_get('menus.cfm', params={'location': location_id})
        print(response)
elif args.subcommand == 'class':
    pass
